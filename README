NAME
    Kappa - super-light ORM

SYNOPSIS
      use Kappa;
      use DBI;
      my $dbh = DBI->connect($dsn, $id, $pw);
      my $db = Kappa->new($dbh);
      my $row_obj = $db->select('SOME_TABLE', { id => 123 });
      print $row_obj->id, $row_obj->value;

DESCRIPTION
    Kappa is a super-light ORM. You can use this module without defining
    schema-class and if you want to define table-related logic, you can
    define table-class for each table.

METHODS
  new($dbh, [$options_href])
    create instance.

    available options are as follows.

    *   row_namespace (string, default 'Kappa::Row') : namespace for row
        object.

    *   table_namespace (string, default 'Kappa') : namespace for table
        class.

      my $dbh = DBI->connect($dsn, $user, $pass);
      my $db = Kappa->new($dbh, {
          row_namespace   => 'MyProj::Row',
          table_namespace => 'MyProj::Table',
      });

  create($table_name)
    create instance for defined table class. if table class for $table_name
    is not found, return default class.

      my $db = Kappa->new($dbh, {
          table_namespace => 'MyProj::Table',
      });
      my $db_for_order = $db->create('Order'); #return table MyProj::Table::Order table class(if defined)

    In this case, Instance of MyProj::Table::Order will be returned. If
    MyProj::Table::Order is not defined, return MyProj::Table instance if
    defiend MyProj::Table and if not defined both of them, return Kappa
    instance.

  row_object_enable($status)
    $status: BOOL enable or disable making row object. if return value is
    required, this value is guard object.

      my $db = Kappa->new($dbh);
      {
          my $guard = $db->row_object_enable(0); #set false to row_object_enable
          my $row = $db->select('SOME_TABLE', { id => 123 }); # $row is not row_object (returns hashref in this case)
      }
      my $row = $db->select('SOME_TABLE', { id => 123 }) # row object is returned.(row_object_enable is currently TRUE)

METHODS FROM PARENT CLASS(SQL::Executor)
    folowing methods are delived from SQL::Executor. Methods named
    select*_itr return Iterator using SQL::Executor::Iterator, and other
    select* methods return Row object(Kappa::Row or child of the one).

  select($table_name, $where, $option)
  select_row($table_name, $where, $option)
  select_all($table_name, $where, $option)
  select_itr($table_name, $where, $option)
  select_named($sql, $params_href, $table_name)
  select_row_named($sql, $params_href, $table_name)
  select_all_named($sql, $params_href, $table_name)
  select_itr_named($sql, $params_href, $table_name)
  select_by_sql($sql, \@binds, $table_name)
  select_row_by_sql($sql, \@binds, $table_name)
  select_all_by_sql($sql, \@binds, $table_name)
  select_itr_by_sql($sql, \@binds, $table_name)
  select_with_fields($table_name, $fields_aref, $where, $option)
  select_row_with_fields($table_name, $fields_aref, $where, $option)
  select_all_with_fields($table_name, $fields_aref, $where, $option)
  select_itr_with_fields($table_name, $fields_aref, $where, $option)
  insert($table_name, $values)
  insert_multi($table_name, @args)
  delete($table_name, $where)
  update($table_name, $set, $where)
DEFINE CUSTOMIZED ROW CLASS
    You can define Row class specified in specified in row_namespace at
    new(). for example, define MyProj::Row::Order like this,

      package MyProj::Row::Order;
      use parent qw(Kappa::Row);
      use strict;
      use warnings;

      sub price_with_tax {
          my ($self) = @_
          return $self->price * $self->tax;
      }

      1;

    using this row object like this,

      my $db = Kappa->new($dbh, { row_namespace => 'MyProj::Row' });
      my @rows = $db->select('Order', { customer_name => 'some_customer' });
      for my $row ( @rows ) {
          print "$row->product_name : $row->price_with_tax \n"; # enable to use customized method(price_with_tax)
      }

    What row object can do is only call calling customized method (in this
    case calling price_with_tax()).

DEFINE CUSTOMIZED TABLE CLASS
    You can also define Table class specified in table_namespace at new().
    for example, define MyProj::Table::Order like this,

      package MyProj::Table::Order;
      use parent qw(Kappa);
      use strict;
      use warnings;

      sub select_using_very_complex_sql {
          my($self, $condition_href) = @_;
          my ($sql, @binds)  = $self->_very_complex_sql($condition_href);
          return $self->select_by_sql($sql, \@binds, $self->table_name); #recommend to pass $self->table_name to make row object for this table
      }
      sub _very_complex_sql { ... }

    using this table class like this,

      my $db = Kappa->new($dbh, { table_namespace => 'MyProj::Table' });
      my $db_for_order = $db->create('Order');
      my @rows = $db_for_order->select_using_very_complex_sql($condition_href);

How to use Transaction.
    You can use DBI's transaction (begin_work and commit).

      use DBI;
      use Kappa
      my $dbh = DBI->connect($dsn, $id, $pass);
      my $db = Kappa->new($dbh);
      $dbh->begin_work();
      $db->insert('SOME_TABLE', { id => 124, value => 'xxxx'} );
      $db->insert('SOME_TABLE', { id => 125, value => 'yyy' } );
      $dbh->commit();

    Or you can also use transaction management modules like
    DBIx::TransactionManager.

      use DBI;
      use Kappa;
      use DBIx::TransactionManager;
      my $dbh = DBI->connect($dsn, $id, $pass);
      my $db = Kappa->new($dbh);
      my $tm = DBIx::TransactionManager->new($dbh);
      my $txn = $tm->txn_scope;
      $db->insert('SOME_TABLE', { id => 124, value => 'xxxx'} );
      $db->insert('SOME_TABLE', { id => 125, value => 'yyy' } );
      $txn->commit;

AUTHOR
    Takuya Tsuchida <tsucchi {at} cpan.org>

SEE ALSO
    SQL::Executor

LICENSE
    Copyright (C) Takuya Tsuchida

    This library is free software; you can redistribute it and/or modify it
    under the same terms as Perl itself.

